def write_lexical_analysis(tokens):
    """Write lexical analysis results to file"""
    with open('lexer_module/lexical_analysis.txt', 'w', encoding='utf-8') as f1:
        f1.write("LEXICAL ANALYSIS\n")
        f1.write("================\n\n")
        for tok in tokens:
            f1.write(f"Line {tok.lineno}: {tok.type}({tok.value})\n")

def write_syntax_analysis(parse_result, errors=None, file=None):
    """
    Reports syntax analysis results.
    
    Args:
        parse_result: The parse tree or None if parsing failed
        errors: List of syntax errors encountered during parsing
        file: Optional file object for writing output
    
    Returns:
        bool: True if syntax is valid, False otherwise
    """
    # Print results to console
    if not parse_result or (errors and len(errors) > 0):
        print(f"Found {len(errors)} syntax error(s):", file=file)
        if errors:
            for error in errors:
                print(f"  {error}", file=file)
        return False
    
    # Write parse tree to file
    with open('parser_module/syntax_analysis.txt', 'w', encoding='utf-8') as f2:

        write_ast(parse_result, f2)
    
    return True

def write_ast(node, file, level=0):
    """Write AST node to file"""
    indent = "  " * level
    
    if isinstance(node, dict):
        # Write node type
        file.write(f"{indent}{node['type']}")
        
        # Add name if present
        if 'name' in node:
            file.write(f" '{node['name']}'")
            
        # Add type info
        if 'data_type' in node:
            if isinstance(node['data_type'], dict):
                file.write(f" : {node['data_type']['name']}")
            else:
                file.write(f" : {node['data_type']}")
                
        # Add value for literals
        if 'value' in node and not isinstance(node['value'], (dict, list)):
            file.write(f" = {node['value']}")
            
        # Add operator for binary operations
        if 'op' in node:
            file.write(f" [{node['op']}]")
            
        file.write("\n")
        
        # Process children in specific order
        for key in ['statements', 'condition', 'then_block', 'else_block', 
                   'body', 'left', 'right', 'params']:
            if key in node and node[key]:
                if key in ['then_block', 'else_block']:
                    file.write(f"{indent}  {key.split('_')[0]}:\n")
                    write_ast(node[key], file, level + 2)
                else:
                    write_ast(node[key], file, level + 1)
    
    elif isinstance(node, list):
        for item in node:
            write_ast(item, file, level) 

def write_semantic_analysis(parse_tree):
    """
    Performs semantic analysis on the parse tree generated by the parser.
    Checks for type compatibility, variable declarations, scope issues, etc.
    
    Args:
        parse_tree: The parse tree generated by the parser
        
    Returns:
        tuple: (is_valid, errors) where:
            - is_valid is a boolean indicating if the code is semantically valid
            - errors is a list of error messages if any were found
    """
    # Initialize symbol table and error list
    symbol_table = {}
    errors = []
    current_scope = ["global"]  # Stack to track nested scopes
    
    def get_scope_name():
        """Returns the current scope name as a string."""
        return ".".join(current_scope)
    
    def add_to_symbol_table(name, type_info, line_no, scope=None):
        """Add a symbol to the symbol table."""
        scope = scope or get_scope_name()
        key = f"{scope}.{name}"
        
        if key in symbol_table:
            errors.append(f"Line {line_no}: Variable '{name}' already declared in {scope} scope")
            return False
        
        symbol_table[key] = {
            'name': name,
            'type': type_info,
            'scope': scope,
            'line': line_no
        }
        return True
    
    def lookup_symbol(name, line_no):
        """Search for a symbol in current and parent scopes."""
        # Start from current scope and move up
        scope_parts = current_scope.copy()
        
        while scope_parts:
            scope = ".".join(scope_parts)
            key = f"{scope}.{name}"
            
            if key in symbol_table:
                return symbol_table[key]
            
            # Remove last scope and try again (move up to parent scope)
            scope_parts.pop()
        
        errors.append(f"Line {line_no}: Variable '{name}' used before declaration")
        return None
    
    def check_type_compatibility(left_type, right_type, operation, line_no):
        """Check if types are compatible for the given operation."""
        # Simple type checking rules
        if operation == 'assignment':
            if left_type != right_type:
                # Special cases for numeric types
                if left_type == 'float_type' and right_type == 'int_type':
                    return True  # Int can be assigned to float
                
                errors.append(f"Line {line_no}: Type mismatch in assignment. Cannot assign {right_type} to {left_type}")
                return False
        
        # For comparison operations
        elif operation in ['==', '!=', '<', '>', '<=', '>=']:
            # Numeric comparisons
            if left_type in ['int_type', 'float_type'] and right_type in ['int_type', 'float_type']:
                return True
            
            # String comparisons
            elif left_type == right_type == 'string_type':
                return True
                
            # Date and time comparisons
            elif left_type == right_type and left_type in ['date_type', 'time_type']:
                return True
                
            # Boolean comparisons
            elif left_type == right_type == 'bool_type':
                return True
                
            errors.append(f"Line {line_no}: Type mismatch in {operation} comparison between {left_type} and {right_type}")
            return False
            
        return True
    
    def analyze_node(node, line_no=0):
        """Recursively analyze a node in the parse tree."""
        if not node:
            return None
            
        # Handle different node types
        if isinstance(node, tuple):
            node_type = node[0]
            
            # Variable declaration
            if node_type == 'declaration':
                _, var_type, var_name, expression = node
                
                # Add variable to symbol table
                add_to_symbol_table(var_name, var_type.lower(), line_no)
                
                # Check expression type
                expr_type = analyze_node(expression, line_no)
                
                # Check type compatibility
                check_type_compatibility(var_type.lower(), expr_type, 'assignment', line_no)
                
                return var_type.lower()
                
            # Variable assignment
            elif node_type == 'assignment':
                _, var_name, expression = node
                
                # Lookup variable
                symbol = lookup_symbol(var_name, line_no)
                if not symbol:
                    return None
                    
                # Check expression type
                expr_type = analyze_node(expression, line_no)
                
                # Check type compatibility
                check_type_compatibility(symbol['type'], expr_type, 'assignment', line_no)
                
                return symbol['type']
                
            # If statement
            elif node_type == 'if':
                _, condition, statements = node
                
                # Enter a new scope
                current_scope.append(f"if_{line_no}")
                
                # Analyze condition
                analyze_node(condition, line_no)
                
                # Analyze statements in the if block
                if isinstance(statements, list):
                    for stmt in statements:
                        analyze_node(stmt, line_no)
                else:
                    analyze_node(statements, line_no)
                
                # Exit the scope
                current_scope.pop()
                
                return None
                
            # Function call
            elif node_type in ('function_call', 'built_in_call'):
                func_name = node[1]
                args = node[2]
                
                # Built-in functions type checking
                if node_type == 'built_in_call':
                    if func_name == 'display':
                        # display can take any type
                        for arg in args:
                            analyze_node(arg, line_no)
                        return None
                    
                    elif func_name == 'gen':
                        # gen should take a string (email)
                        if len(args) != 1:
                            errors.append(f"Line {line_no}: Function 'gen' requires exactly 1 argument")
                        else:
                            arg_type = analyze_node(args[0], line_no)
                            if arg_type != 'string_type':
                                errors.append(f"Line {line_no}: Function 'gen' requires a string argument")
                        return 'string_type'  # gen returns a string (userID)
                    
                    elif func_name == 'reg':
                        # reg takes userID, name, email, phone
                        if len(args) != 4:
                            errors.append(f"Line {line_no}: Function 'reg' requires exactly 4 arguments")
                        else:
                            # Check argument types
                            arg_types = [analyze_node(arg, line_no) for arg in args]
                            expected_types = ['string_type', 'string_type', 'string_type', 'string_type']
                            
                            for i, (actual, expected) in enumerate(zip(arg_types, expected_types)):
                                if actual != expected:
                                    errors.append(f"Line {line_no}: Function 'reg' argument {i+1} should be {expected}")
                        return None
                    
                    elif func_name == 'book':
                        # book takes event, userID, quantity
                        if len(args) != 3:
                            errors.append(f"Line {line_no}: Function 'book' requires exactly 3 arguments")
                        else:
                            # Check argument types
                            arg_types = [analyze_node(arg, line_no) for arg in args]
                            expected_types = ['string_type', 'string_type', 'int_type']
                            
                            for i, (actual, expected) in enumerate(zip(arg_types, expected_types)):
                                if actual != expected:
                                    errors.append(f"Line {line_no}: Function 'book' argument {i+1} should be {expected}")
                        return 'bool_type'  # book returns success/failure
                
                # User-defined function calls would need a function table
                # For now, we'll just analyze the arguments
                else:
                    for arg in args:
                        analyze_node(arg, line_no)
                    return 'unknown'  # Can't determine return type of user functions yet
            
            # Condition
            elif node_type == 'condition':
                _, operator, left_expr, right_expr = node
                
                # Analyze expressions
                left_type = analyze_node(left_expr, line_no)
                right_type = analyze_node(right_expr, line_no)
                
                # Check type compatibility for the condition
                check_type_compatibility(left_type, right_type, operator, line_no)
                
                return 'bool_type'
                
            # Expression
            elif node_type == 'expression':
                expr_value = node[1]
                
                # If it's a literal
                if isinstance(expr_value, (int, float)):
                    return 'int_type' if isinstance(expr_value, int) else 'float_type'
                
                elif isinstance(expr_value, str):
                    # Determine type based on pattern
                    if expr_value.startswith('"') and expr_value.endswith('"'):
                        return 'string_type'
                        
                    # Date format check (simple)
                    elif len(expr_value.split('-')) == 3:
                        return 'date_type'
                        
                    # Time format check (simple)
                    elif len(expr_value.split(':')) == 3:
                        return 'time_type'
                        
                    # Boolean literal
                    elif expr_value in ('True', 'False'):
                        return 'bool_type'
                        
                    # It's an identifier
                    else:
                        symbol = lookup_symbol(expr_value, line_no)
                        return symbol['type'] if symbol else 'unknown'
                
                # It's a sub-expression (like a function call)
                else:
                    return analyze_node(expr_value, line_no)
            
            # Default case for unhandled node types
            else:
                print(f"Warning: Unhandled node type: {node_type}")
                return 'unknown'
                
        # List of statements
        elif isinstance(node, list):
            for item in node:
                analyze_node(item, line_no)
            return None
            
        # Literal values
        elif isinstance(node, (int, float, str, bool)):
            # Determine type of literal
            if isinstance(node, int):
                return 'int_type'
            elif isinstance(node, float):
                return 'float_type'
            elif isinstance(node, bool):
                return 'bool_type'
            elif isinstance(node, str):
                # Could be string, date, or time based on format
                return 'string_type'
        
        return 'unknown'
    
    # Start analysis from the root of the parse tree
    if parse_tree and parse_tree[0] == 'program':
        statements = parse_tree[1]
        for statement in statements:
            analyze_node(statement)
            
    # Return results
    is_valid = len(errors) == 0
    return (is_valid, errors, symbol_table)
